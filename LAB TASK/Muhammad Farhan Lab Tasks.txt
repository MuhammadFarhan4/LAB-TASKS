
lab 1

#include<iostream>
using namespace std;

int main() {
    int a = 1;
    int *ptr = &a;

    cout << "Before\n";
    cout << " A : " << a << endl;
    cout << " *Ptr : " << *ptr << endl;

    cout << "After\n";
    *ptr = 9;  
    cout << " A : " << a << endl;
    cout << " *Ptr : " << *ptr << endl;
    ptr = nullptr; 

    return 0;
}


lab 2

#include<iostream>
using namespace std;

int findMax(int arr[], int length) {
    int maximum = arr[0];
    for (int i = 1; i < length; i++) {
        if (arr[i] > maximum) {
            maximum = arr[i];
        }
    }
    return maximum;
}

int main() {
    int numbers[] = {9, 18, 8, 1, 6};
    int maxNum = findMax(numbers, 5);
    cout << "Max " << maxNum << endl;

    return 0;
}


lab 3

#include<iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node(int d) : data(d), next(nullptr) {}
};

class LinkedList {
    Node* head;
public:
    LinkedList() : head(nullptr) {}

    void addAtBeginning(int value) {
        Node* newNode = new Node(value);
        newNode->next = head;
        head = newNode;
    }

    void addAtEnd(int value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = newNode;
        } else {
            Node* temp = head;
            while (temp->next) {
                temp = temp->next;
            }
            temp->next = newNode;
        }
    }

    void printList() {
        Node* temp = head;
        while (temp) {
            cout << temp->data;
            if (temp->next) cout << ", ";
            temp = temp->next;
        }
        cout << endl;
    }
};

int main() {
    LinkedList list;
    list.addAtBeginning(9);
    list.addAtEnd(18);
    list.addAtEnd(35);
    cout << "Linked List: ";
    list.printList();

    return 0;
}


  lab 4 

 #include<iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node(int value) : data(value), next(nullptr) {}
};

class LinkedList {
    Node* head;
public:
    LinkedList() : head(nullptr) {}

    void addFirst(int value) {
        Node* newNode = new Node(value);
        newNode->next = head;
        head = newNode;
    }

    void addLast(int value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = newNode;
        } else {
            Node* temp = head;
            while (temp->next) {
                temp = temp->next;
            }
            temp->next = newNode;
        }
    }

    void addAt(int value, int position) {
        if (position < 1) {
            cout << "Invalid Position.\n";
            return;
        }
        if (position == 1) {
            addFirst(value);
            return;
        }

        Node* newNode = new Node(value);
        Node* temp = head;
        int count = 1;
        while (temp && count < position - 1) {
            temp = temp->next;
            count++;
        }

        if (!temp) {
            cout << "Position out of bounds.\n";
            delete newNode;
            return;
        }

        newNode->next = temp->next;
        temp->next = newNode;
    }

    void display() {
        Node* temp = head;
        while (temp) {
            cout << temp->data << " -> ";
            temp = temp->next;
        }
        cout << "NULL\n";
    }
};

int main() {
    LinkedList list;
    list.addFirst(10);
    list.addLast(20);
    list.addLast(30);
    list.addAt(25, 3);
    list.display();
    return 0;
}


lab 5

#include<iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;

    Node(int value) : data(value), next(nullptr) {}
};

class LinkedList {
    Node* head;
public:
    LinkedList() : head(nullptr) {}

    void addFirst(int value) {
        Node* newNode = new Node(value);
        newNode->next = head;
        head = newNode;
    }

    void addLast(int value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = newNode;
        } else {
            Node* temp = head;
            while (temp->next) {
                temp = temp->next;
            }
            temp->next = newNode;
        }
    }

    void addAtPosition(int value, int position) {
        if (position < 1) {
            cout << "Invalid Position\n";
            return;
        }
        if (position == 1) {
            addFirst(value);
        } else {
            Node* newNode = new Node(value);
            Node* temp = head;
            for (int i = 1; i < position - 1 && temp; ++i) {
                temp = temp->next;
            }
            if (!temp) {
                cout << "Invalid Position\n";
                return;
            }
            newNode->next = temp->next;
            temp->next = newNode;
        }
    }

    void printList() {
        Node* temp = head;
        while (temp) {
            cout << temp->data;
            if (temp->next) cout << ", ";
            temp = temp->next;
        }
        cout << endl;
    }

    void printFirst() {
        if (head) cout << head->data << endl;
    }

    void printLast() {
        if (!head) return;
        Node* temp = head;
        while (temp->next) {
            temp = temp->next;
        }
        cout << temp->data << endl;
    }

    void printMiddle() {
        if (!head) return;
        Node* temp = head;
        int count = 0;
        while (temp) {
            count++;
            temp = temp->next;
        }
        temp = head;
        for (int i = 1; i < count / 2; ++i) {
            temp = temp->next;
        }
        cout << temp->data << endl;
    }
};

int main() {
    LinkedList list;
    list.addFirst(9);
    list.addFirst(93);
    list.addLast(0);
    list.addLast(88);
    list.addAtPosition(8, 2);
    list.addAtPosition(18, 2);

    cout << "First Node: ";
    list.printFirst();

    cout << "Last Node: ";
    list.printLast();

    cout << "Middle Node: ";
    list.printMiddle();

    cout << "Linked List: ";
    list.printList();

    return 0;
}



   lab 6
   
   
   #include<iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node(int value) : data(value), next(nullptr) {}
};

class LinkedList {
    Node* head;
public:
    LinkedList() : head(nullptr) {}

    void addFirst(int value) {
        Node* newNode = new Node(value);
        newNode->next = head;
        head = newNode;
    }

    void addLast(int value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = newNode;
        } else {
            Node* temp = head;
            while (temp->next) {
                temp = temp->next;
            }
            temp->next = newNode;
        }
    }

    void addAtPosition(int value, int position) {
        if (position < 1) {
            cout << "Invalid Position.\n";
            return;
        } 
        if (position == 1) {
            addFirst(value);
        } else {
            Node* newNode = new Node(value);
            Node* temp = head;
            for (int i = 1; i < position - 1 && temp; ++i) {
                temp = temp->next;
            }
            if (!temp) {
                cout << "Invalid Position.\n";
            } else {
                newNode->next = temp->next;
                temp->next = newNode;
            }
        }
    }

    void removeFirst() {
        if (head) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }

    void removeAtPosition(int position) {
        if (position < 1) {
            cout << "Invalid Position.\n";
            return;
        }
        if (position == 1) {
            removeFirst();
        } else {
            Node* temp = head;
            for (int i = 1; i < position - 1 && temp; ++i) {
                temp = temp->next;
            }
            if (!temp || !temp->next) {
                cout << "Invalid Position.\n";
                return;
            }
            Node* toDelete = temp->next;
            temp->next = temp->next->next;
            delete toDelete;
        }
    }

    void removeLast() {
        if (head) {
            if (!head->next) {
                delete head;
                head = nullptr;
            } else {
                Node* temp = head;
                while (temp->next && temp->next->next) {
                    temp = temp->next;
                }
                delete temp->next;
                temp->next = nullptr;
            }
        }
    }

    void removeCenter() {
        if (head) {
            Node* temp = head;
            int count = 0;
            while (temp) {
                count++;
                temp = temp->next;
            }
            if (count < 3) return; 
            temp = head;
            for (int i = 1; i < count / 2; ++i) {
                temp = temp->next;
            }
            Node* toDelete = temp->next;
            temp->next = temp->next->next;
            delete toDelete;
        }
    }

    void removeByValue(int value) {
        if (head) {
            if (head->data == value) {
                removeFirst();
                return;
            }
            Node* temp = head;
            while (temp->next && temp->next->data != value) {
                temp = temp->next;
            }
            if (temp->next) {
                Node* toDelete = temp->next;
                temp->next = temp->next->next;
                delete toDelete;
            }
        }
    }

    void printList() {
        Node* temp = head;
        while (temp) {
            cout << temp->data;
            if (temp->next) cout << ", ";
            temp = temp->next;
        }
        cout << endl;
    }

    void printFirst() {
        if (head) cout << head->data << endl;
    }

    void printLast() {
        if (head) {
            Node* temp = head;
            while (temp->next) {
                temp = temp->next;
            }
            cout << temp->data << endl;
        }
    }

    void printCenter() {
        if (head) {
            Node* temp = head;
            int count = 0;
            while (temp) {
                count++;
                temp = temp->next;
            }
            if (count < 3) return; 
            temp = head;
            for (int i = 1; i < count / 2; ++i) {
                temp = temp->next;
            }
            cout << temp->data << endl;
        }
    }
};

int main() {
    LinkedList list;

    list.addFirst(9);
    list.addFirst(93);
    list.addLast(0);
    list.addLast(88);
    list.addAtPosition(8, 2);
    list.addAtPosition(77, 3);
    list.addAtPosition(18, 2);

    cout << "Before List: ";
    list.printList();
    cout << "First Node: ";
    list.printFirst();
    cout << "Last Node: ";
    list.printLast();
    cout << "Center Node: ";
    list.printCenter();

    cout << "--------------------------------------------\n";
    cout << "Deleting Last Node.\n";
    list.removeLast();
    cout << "Last Node: ";
    list.printLast();

    cout << "Deleting First Node.\n";
    list.removeFirst();
    cout << "First Node: ";
    list.printFirst();

    cout << "Deleting Center Node.\n";
    list.removeCenter();
    cout << "Center Node: ";
    list.printCenter();

    cout << "Final List: ";
    list.printList();

    return 0;
}


   lab 7
#include<iostream>
using namespace std;

class Node {
public:
    int data;
    Node* prev;
    Node* next;

    Node(int d = 0) {
        data = d;
        prev = NULL;
        next = NULL;
    }
};

class DoublyList {
    Node* head;
    Node* tail;

public:
    DoublyList() {
        head = NULL;
    }

    void insertAtFirst(int d) {
        Node* newNode = new Node(d);
        if (head == NULL) {
            head = newNode;
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
    }

    void insertAtLast(int d) {
        Node* newNode = new Node(d);
        if (head == NULL) {
            head = newNode;
        } else {
            Node* temp = head;
            while (temp->next != NULL) {
                temp = temp->next;
            }
            newNode->prev = temp;
            temp->next = newNode;
        }
    }

    void insertAtCenter(int d) {
        Node* newNode = new Node(d);
        if (head == NULL) {
            head = newNode;
        } else {
            Node* temp = head;
            int count = 1;
            while (temp->next != NULL) {
                temp = temp->next;
                count++;
            }
            temp = head;
            for (int i = 1; i <= count / 2; i++) {
                temp = temp->next;
            }
            newNode->next = temp->next;
            newNode->prev = temp;
            temp->next->prev = newNode;
            temp->next = newNode;
        }
    }

    void insertAtSpecificPosition(int d, int pos) {
        Node* newNode = new Node(d);
        if (head == NULL) {
            head = newNode;
        } else if (pos < 1) {
            cout << "Invalid Position\n";
        } else if (pos == 1) {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        } else {
            Node* temp = head;
            for (int i = 1; i < pos; i++) {
                temp = temp->next;
                if (temp == NULL) {
                    break;
                }
            }
            newNode->prev = temp;
            newNode->next = temp->next;
            temp->next->prev = newNode;
            temp->next = newNode;
        }
    }

    void displayInOrder() {
        Node* temp = head;
        cout << "Doubly Linked List: ";
        while (temp != NULL) {
            cout << temp->data << " ";
            temp = temp->next;
            if (temp != NULL) {
                cout << ", ";
            }
        }
        cout << endl;
    }

    void displayInReverse() {
        Node* temp = head;
        cout << "Reversed Doubly Linked List: ";
        while (temp->next != NULL) {
            temp = temp->next;
        }
        while (temp != NULL) {
            cout << temp->data << " ";
            if (temp->prev != NULL) {
                cout << ", ";
            }
            temp = temp->prev;
        }
        cout << endl;
    }
};

int main() {
    DoublyList d;

    d.insertAtFirst(50);
    d.insertAtLast(99);
    d.insertAtLast(27);
    d.insertAtLast(75);
    d.insertAtSpecificPosition(63, 2);
    d.displayInOrder();
    d.displayInReverse();

    d.insertAtCenter(18);
    cout << "-----------------------------------------.\n";
    cout << "After Adding the Center Node.\n";
    d.displayInOrder();
    d.displayInReverse();

    return 0;
}

lab 8
#include <iostream>
using namespace std;

class Node {
public:
    string data;
    Node* next;
    Node* prev;

    Node(string data) {
        this->data = data;
        this->next = NULL;
        this->prev = NULL;
    }
};

class SinglyLinkedList {
public:
    Node* head;

    SinglyLinkedList() {
        head = NULL;
    }

    void insertLast(string data) {
        Node* newNode = new Node(data);
        if (head == NULL) {
            head = newNode;
            return;
        }
        Node* temp = head;
        while (temp->next != NULL) {
            temp = temp->next;
        }
        temp->next = newNode;
    }

    void mergeList(SinglyLinkedList &list2) {
        if (head == NULL) {
            head = list2.head;
            return;
        }
        Node* temp = head;
        while (temp->next != NULL) {
            temp = temp->next;
        }
        temp->next = list2.head;
    }

    void printList() {
        Node* temp = head;
        while (temp != NULL) {
            cout << temp->data << " -> ";
            temp = temp->next;
        }
        cout << "NULL" << endl;
    }
};

class DoublyLinkedList {
public:
    Node* head;
    Node* tail;

    DoublyLinkedList() {
        head = NULL;
        tail = NULL;
    }

    void insertLast(string data) {
        Node* newNode = new Node(data);
        if (head == NULL) {
            head = tail = newNode;
            return;
        }
        tail->next = newNode;
        newNode->prev = tail;
        tail = newNode;
    }

    void mergeList(DoublyLinkedList &list2) {
        if (head == NULL) {
            head = list2.head;
            tail = list2.tail;
            return;
        }
        if (list2.head == NULL) return;
        tail->next = list2.head;
        list2.head->prev = tail;
        tail = list2.tail;
    }

    void printList() {
        Node* temp = head;
        while (temp != NULL) {
            cout << temp->data << " <-> ";
            temp = temp->next;
        }
        cout << "NULL" << endl;
    }
};

int main() {
    SinglyLinkedList s1, s2;
    s1.insertLast("Ali");
    s1.insertLast("Faizan");
    s1.insertLast("Shoaib");

    s2.insertLast("Hasnain");
    s2.insertLast("Najam");

    cout << "Singly Linked List 1: ";
    s1.printList();

    cout << "Singly Linked List 2: ";
    s2.printList();

    s1.mergeList(s2);
    cout << "Merged Singly Linked List: ";
    s1.printList();

    DoublyLinkedList d1, d2;
    d1.insertLast("Ali");
    d1.insertLast("Faizan");
    d1.insertLast("Shoaib");

    d2.insertLast("Hasnain");
    d2.insertLast("Najam");

    cout << "Doubly Linked List 1: ";
    d1.printList();

    cout << "Doubly Linked List 2: ";
    d2.printList();

    d1.mergeList(d2);
    cout << "Merged Doubly Linked List: ";
    d1.printList();

    return 0;
}



Lab 9
#include <iostream>
using namespace std;

class Node {
public:
    string value;
    Node* link;

    Node(string val) {
        this->value = val;
        this->link = NULL;
    }
};

class circularList {
public:
    Node* start;

    circularList() {  
        start = NULL;
    }

    void insertAtBeginning(string val) {
        Node* newNode = new Node(val);
        if (start == NULL) {
            start = newNode;
            start->link = start;  
        } else {
            Node* temp = start;
            while (temp->link != start) {
                temp = temp->link;
            }
            newNode->link = start;
            temp->link = newNode;
            start = newNode;  
        }
    }

    void insertAtEnd(string val) {
        Node* newNode = new Node(val);
        if (start == NULL) {
            start = newNode;
            start->link = start;  
        } else {
            Node* temp = start;
            while (temp->link != start) {
                temp = temp->link;
            }
            temp->link = newNode;
            newNode->link = start;
        }
    }

    void insertAtPosition(int pos, string val) {
        Node* newNode = new Node(val);
        if (pos == 1 || start == NULL) {
            insertAtBeginning(val);
            return;
        }

        Node* temp = start;
        for (int i = 1; i < pos - 1 && temp->link != start; i++) {
            temp = temp->link;
        }

        newNode->link = temp->link;
        temp->link = newNode;
    }

    void insertAtMiddle(string val) {
        if (start == NULL) {
            insertAtBeginning(val);
            return;
        }

        Node* slow = start;
        Node* fast = start;
        while (fast->link != start && fast->link->link != start) {
            slow = slow->link;
            fast = fast->link->link;
        }

        Node* newNode = new Node(val);
        newNode->link = slow->link;
        slow->link = newNode;
    }

    void displayList() {
        if (start == NULL) {
            cout << "List is empty!\n";
            return;
        }
        Node* temp = start;
        cout << "Circular Linked List: ";
        do {
            cout << temp->value << " -> ";
            temp = temp->link;
        } while (temp != start);
        cout << "(start)" << endl;
    }

    void reverseDisplay() {
        if (start == NULL) {
            cout << "List is empty!\n";
            return;
        }

        Node* temp = start;
        Node* prev = NULL;
        Node* curr = start;

        do {
            Node* nextNode = curr->link;
            curr->link = prev;
            prev = curr;
            curr = nextNode;
        } while (curr != start);

        start->link = prev;
        start = prev;

        cout << "Reversed List: ";
        temp = start;
        do {
            cout << temp->value << " -> ";
            temp = temp->link;
        } while (temp != start);
        cout << "(start)" << endl;
    }
};

int main() {
    circularList list;

    list.insertAtBeginning("hasnain");
    list.insertAtEnd("hammad");
    list.insertAtPosition(2, "muhammad");
    list.insertAtEnd("shoaib");
    list.insertAtMiddle("farhan");

    list.displayList();
    list.reverseDisplay();

    return 0;
}
lab 10
#include<iostream>
using namespace std;


class StackNode {
public:
    int value;
    StackNode* nextNode;

    StackNode(int val = -1) {
        value = val;
        nextNode = nullptr;
    }
};


class LinkedStack {
private:
    StackNode* stackTop;

public:
    LinkedStack() {
        stackTop = nullptr;
    }

    void insertTop(int val) {
        StackNode* temp = new StackNode(val);
        temp->nextNode = stackTop;
        stackTop = temp;
    }

    void removeTop() {
        if (!stackTop) return;
        StackNode* toDelete = stackTop;
        stackTop = stackTop->nextNode;
        delete toDelete;
    }

    void insertBottom(int val) {
        StackNode* temp = stackTop;
        StackNode* newNode = new StackNode(val);
        if (!temp) {
            stackTop = newNode;
            return;
        }
        while (temp->nextNode) {
            temp = temp->nextNode;
        }
        temp->nextNode = newNode;
    }

    void removeBottom() {
        if (!stackTop) return;
        if (!stackTop->nextNode) {
            delete stackTop;
            stackTop = nullptr;
            return;
        }
        StackNode* temp = stackTop;
        while (temp->nextNode->nextNode) {
            temp = temp->nextNode;
        }
        delete temp->nextNode;
        temp->nextNode = nullptr;
    }

    void printStack() {
        StackNode* current = stackTop;
        while (current) {
            cout << current->value;
            if (current->nextNode) cout << " -> ";
            current = current->nextNode;
        }
        cout << endl;
    }
};

// Stack implementation using Array
class ArrayStack {
private:
    int items[100];
    int indexTop;

public:
    ArrayStack() {
        indexTop = -1;
    }

    void pushElement(int val) {
        if (indexTop >= 99) {
            cout << "Array Stack Overflow!\n";
            return;
        }
        items[++indexTop] = val;
    }

    void popElement() {
        if (indexTop == -1) {
            cout << "Array Stack Underflow!\n";
            return;
        }
        indexTop--;
    }

    void pushToBottom(int val) {
        if (indexTop >= 99) return;
        indexTop++;
        for (int i = indexTop; i > 0; --i) {
            items[i] = items[i - 1];
        }
        items[0] = val;
    }

    void popFromBottom() {
        if (indexTop == -1) return;
        for (int i = 0; i < indexTop; ++i) {
            items[i] = items[i + 1];
        }
        indexTop--;
    }

    void displayStack() {
        for (int i = 0; i <= indexTop; ++i) {
            cout << items[i];
            if (i < indexTop) cout << " | ";
        }
        cout << endl;
    }
};

int main() {
    LinkedStack linkS;
    ArrayStack arrS;

    cout << "--- Linked List Based Stack ---\n";
    linkS.insertTop(10);
    linkS.insertTop(20);
    linkS.insertTop(30);
    linkS.printStack();

    cout << "After inserting at bottom:\n";
    linkS.insertBottom(99);
    linkS.printStack();

    cout << "After removing bottom:\n";
    linkS.removeBottom();
    linkS.printStack();

    cout << "After popping top:\n";
    linkS.removeTop();
    linkS.printStack();

    cout << "\n--- Array Based Stack ---\n";
    arrS.pushElement(1);
    arrS.pushElement(2);
    arrS.pushElement(3);
    arrS.displayStack();

    cout << "After pushing at bottom:\n";
    arrS.pushToBottom(0);
    arrS.displayStack();

    cout << "After popping from bottom:\n";
    arrS.popFromBottom();
    arrS.displayStack();

    cout << "After popping top:\n";
    arrS.popElement();
    arrS.displayStack();

    return 0;
}
lab 11
#include<iostream>
using namespace std;

class ItemNode {
public:
    int data;
    ItemNode* nextItem;

    ItemNode(int value = 0) {
        data = value;
        nextItem = nullptr;
    }
};

class LinkedQueue {
private:
    ItemNode* frontItem;
    ItemNode* rearItem;

public:
    LinkedQueue() {
        frontItem = nullptr;
        rearItem = nullptr;
    }

    void addItem(int value) {
        ItemNode* newNode = new ItemNode(value);
        if (rearItem != nullptr) {
            rearItem->nextItem = newNode;
            rearItem = newNode;
        } else {
            frontItem = rearItem = newNode;
        }
    }

    void removeItem() {
        if (!frontItem) return;
        ItemNode* temp = frontItem;
        frontItem = frontItem->nextItem;
        if (!frontItem) rearItem = nullptr;
        delete temp;
    }

    void showQueue() {
        cout << "Queue: ";
        ItemNode* temp = frontItem;
        while (temp) {
            cout << temp->data;
            if (temp->nextItem) cout << " -> ";
            temp = temp->nextItem;
        }
        cout << endl;
    }
};

class ArrayQueue {
private:
    int array[100];
    int count;

public:
    ArrayQueue() {
        count = 0;
    }

    void addItem(int value) {
        if (count == 100) {
            cout << "Queue is full!" << endl;
            return;
        }
        array[count++] = value;
    }

    void removeItem() {
        if (count == 0) return;
        for (int i = 0; i < count - 1; ++i) {
            array[i] = array[i + 1];
        }
        count--;
    }

    void showQueue() {
        cout << "Array Queue: ";
        for (int i = 0; i < count; ++i) {
            cout << array[i];
            if (i != count - 1) cout << " -> ";
        }
        cout << endl;
    }
};

int main() {
    cout << "Queue follows the FIFO (First In First Out) Rule\n\n";
    
    cout << "Linked List Based Queue\n";
    LinkedQueue linkedQueue;
    linkedQueue.addItem(99);
    linkedQueue.addItem(89);
    linkedQueue.addItem(79);
    linkedQueue.addItem(819);
    linkedQueue.addItem(59);
    linkedQueue.showQueue();
    cout << "After removing an item:\n";
    linkedQueue.removeItem();
    linkedQueue.showQueue();

    cout << "\nArray Based Queue\n";
    ArrayQueue arrayQueue;
    arrayQueue.addItem(22);
    arrayQueue.addItem(29);
    arrayQueue.addItem(99);
    arrayQueue.addItem(37);
    arrayQueue.addItem(19);
    arrayQueue.addItem(67);
    arrayQueue.showQueue();
    cout << "After removing an item:\n";
    arrayQueue.removeItem();
    arrayQueue.showQueue();

    return 0;
}

LAB 12 PART 1

#include<iostream>

using namespace std;

struct Node {
    int key, height;
    Node *left, *right;

    Node(int k = 0) {
        key = k;
        left = nullptr;
        right = nullptr;
        height = 1;
    }
};

class Avl {
    Node* root;

    int max(int a, int b) {
        return (a > b) ? a : b;
    }

    int height(Node* N) {
        if (N == nullptr) return 0;
        return N->height;
    }

    Node* rightRotate(Node* y) {
        Node* x = y->left;
        Node* t2 = x->right;

        x->right = y;
        y->left = t2;

        y->height = 1 + max(height(y->left), height(y->right));
        x->height = 1 + max(height(x->left), height(x->right));

        return x;
    }

    Node* leftRotate(Node* x) {
        Node* y = x->right;
        Node* t2 = y->left;

        y->left = x;
        x->right = t2;

        x->height = 1 + max(height(x->left), height(x->right));
        y->height = 1 + max(height(y->left), height(y->right));

        return y;
    }

    Node* minValueNode(Node* node) {
        Node* current = node;
        while (current && current->left != nullptr)
            current = current->left;
        return current;
    }

    Node* deleteNodeHelper(Node* node, int key) {
        if (node == nullptr) return node;

        if (key < node->key)
            node->left = deleteNodeHelper(node->left, key);
        else if (key > node->key)
            node->right = deleteNodeHelper(node->right, key);
        else {
            if (node->left == nullptr || node->right == nullptr) {
                Node* temp = node->left ? node->left : node->right;
                if (temp == nullptr) {
                    temp = node;
                    node = nullptr;
                } 
                else {
                    *node = *temp;
                }
                delete temp;
            } 
            else {
                Node* temp = minValueNode(node->right);
                node->key = temp->key;
                node->right = deleteNodeHelper(node->right, temp->key);
            }
        }

        if (node == nullptr) return node;

        node->height = 1 + max(height(node->left), height(node->right));

        int balance = getBalancedFactor(node);

        if (balance > 1 && getBalancedFactor(node->left) >= 0)
            return rightRotate(node);

        if (balance > 1 && getBalancedFactor(node->left) < 0) {
            node->left = leftRotate(node->left);
            return rightRotate(node);
        }

        if (balance < -1 && getBalancedFactor(node->right) <= 0)
            return leftRotate(node);

        if (balance < -1 && getBalancedFactor(node->right) > 0) {
            node->right = rightRotate(node->right);
            return leftRotate(node);
        }

        return node;
    }

    Node* insertNode(Node* node, int key) {
        if (node == nullptr)
            return new Node(key);

        if (key < node->key)
            node->left = insertNode(node->left, key);
        else if (key > node->key)
            node->right = insertNode(node->right, key);
        else
            return node;

        node->height = 1 + max(height(node->left), height(node->right));

        int balance = getBalancedFactor(node);

        if (balance > 1 && key < node->left->key)
            return rightRotate(node);

        if (balance < -1 && key > node->right->key)
            return leftRotate(node);

        if (balance > 1 && key > node->left->key) {
            node->left = leftRotate(node->left);
            return rightRotate(node);
        }

        if (balance < -1 && key < node->right->key) {
            node->right = rightRotate(node->right);
            return leftRotate(node);
        }

        return node;
    }

public:
    Avl() {
        root = nullptr;
    }

    int getBalancedFactor(Node* node) {
        if (node == nullptr) return 0;
        return height(node->left) - height(node->right);
    }

    void insert(int key) {
        root = insertNode(root, key);
    }

    void deleteNode(int key) {
        root = deleteNodeHelper(root, key);
    }

    void inorder(Node* node) {
        if (node == nullptr) return;
        inorder(node->left);
        cout << node->key << " -> ";
        inorder(node->right);
    }

    void preorder(Node* node) {
        if (node != nullptr) {
            cout << node->key << " ";
            preorder(node->left);
            preorder(node->right);
        }
    }

    Node* getRoot() const { return root; }
};

int main() {
    int nodes[] = { 12, 25, 35, 50, 60, 30 };
    Avl avl;
    
    for (int key: nodes)
    {
        avl.insert(key);
    }

    cout << "Preorder traversal before deletion: ";
    avl.preorder(avl.getRoot());
    cout << endl;

    avl.deleteNode(35);

    cout << "Preorder traversal after deletion: ";
    avl.preorder(avl.getRoot());
    cout << endl;

    return 0;
}

LAB 12 
PART 2

#include<iostream>

using namespace std;

struct Node {
    int key, height;
    Node *left, *right;

    Node(int k = 0) {
        key = k;
        left = nullptr;
        right = nullptr;
        height = 1;
    }
};

class Avl {
    Node* root;

    int max(int a, int b) {
        return (a > b) ? a : b;
    }

    int height(Node* N) {
        if (N == nullptr) return 0;
        return N->height;
    }

    Node* rightRotate(Node* y) {
        Node* x = y->left;
        Node* t2 = x->right;

        x->right = y;
        y->left = t2;

        y->height = 1 + max(height(y->left), height(y->right));
        x->height = 1 + max(height(x->left), height(x->right));

        return x;
    }

    Node* leftRotate(Node* x) {
        Node* y = x->right;
        Node* t2 = y->left;

        y->left = x;
        x->right = t2;

        x->height = 1 + max(height(x->left), height(x->right));
        y->height = 1 + max(height(y->left), height(y->right));

        return y;
    }

    Node* minValueNode(Node* node) {
        Node* current = node;
        while (current && current->left != nullptr)
            current = current->left;
        return current;
    }

    Node* deleteNodeHelper(Node* node, int key) {
        if (node == nullptr) return node;

        if (key < node->key)
            node->left = deleteNodeHelper(node->left, key);
        else if (key > node->key)
            node->right = deleteNodeHelper(node->right, key);
        else {
            if (node->left == nullptr || node->right == nullptr) {
                Node* temp = node->left ? node->left : node->right;
                if (temp == nullptr) {
                    temp = node;
                    node = nullptr;
                } 
                else {
                    *node = *temp;
                }
                delete temp;
            } 
            else {
                Node* temp = minValueNode(node->right);
                node->key = temp->key;
                node->right = deleteNodeHelper(node->right, temp->key);
            }
        }

        if (node == nullptr) return node;

        node->height = 1 + max(height(node->left), height(node->right));

        int balance = getBalancedFactor(node);

        if (balance > 1 && getBalancedFactor(node->left) >= 0)
            return rightRotate(node);

        if (balance > 1 && getBalancedFactor(node->left) < 0) {
            node->left = leftRotate(node->left);
            return rightRotate(node);
        }

        if (balance < -1 && getBalancedFactor(node->right) <= 0)
            return leftRotate(node);

        if (balance < -1 && getBalancedFactor(node->right) > 0) {
            node->right = rightRotate(node->right);
            return leftRotate(node);
        }

        return node;
    }

    Node* insertNode(Node* node, int key) {
        if (node == nullptr)
            return new Node(key);

        if (key < node->key)
            node->left = insertNode(node->left, key);
        else if (key > node->key)
            node->right = insertNode(node->right, key);
        else
            return node;

        node->height = 1 + max(height(node->left), height(node->right));

        int balance = getBalancedFactor(node);

        if (balance > 1 && key < node->left->key)
            return rightRotate(node);

        if (balance < -1 && key > node->right->key)
            return leftRotate(node);

        if (balance > 1 && key > node->left->key) {
            node->left = leftRotate(node->left);
            return rightRotate(node);
        }

        if (balance < -1 && key < node->right->key) {
            node->right = rightRotate(node->right);
            return leftRotate(node);
        }

        return node;
    }

public:
    Avl() {
        root = nullptr;
    }

    int getBalancedFactor(Node* node) {
        if (node == nullptr) return 0;
        return height(node->left) - height(node->right);
    }

    void insert(int key) {
        root = insertNode(root, key);
    }

    void deleteNode(int key) {
        root = deleteNodeHelper(root, key);
    }

    void inorder(Node* node) {
        if (node == nullptr) return;
        inorder(node->left);
        cout << node->key << " -> ";
        inorder(node->right);
    }

    void preorder(Node* node) {
        if (node != nullptr) {
            cout << node->key << " ";
            preorder(node->left);
            preorder(node->right);
        }
    }

    Node* getRoot() const { return root; }
};

int main() {
    int nodes[] = { 12, 25, 35, 50, 60, 30 };
    Avl avl;
    
    for (int key: nodes)
    {
        avl.insert(key);
    }

    cout << "Preorder traversal before deletion: ";
    avl.preorder(avl.getRoot());
    cout << endl;

    avl.deleteNode(35);

    cout << "Preorder traversal after deletion: ";
    avl.preorder(avl.getRoot());
    cout << endl;

    return 0;
}

LAB 13
part 1
#include <iostream>
using namespace std;

struct TreeNode {
    int data;
    TreeNode* leftChild;
    TreeNode* rightChild;
    TreeNode(int val) : data(val), leftChild(nullptr), rightChild(nullptr) {}
};

class TreeTraversal {
public:
    TreeNode* rootNode;

    TreeTraversal() : rootNode(nullptr) {}

    void insertValue(int val) {
        rootNode = insertHelper(rootNode, val);
    }

    void depthFirstSearch(TreeNode* node) {
        if (node == nullptr) return;
        cout << node->data << " ";
        depthFirstSearch(node->leftChild);
        depthFirstSearch(node->rightChild);
    }

private:
    TreeNode* insertHelper(TreeNode* node, int val) {
        if (node == nullptr) return new TreeNode(val);
        if (val < node->data) {
            node->leftChild = insertHelper(node->leftChild, val);
        } else {
            node->rightChild = insertHelper(node->rightChild, val);
        }
        return node;
    }
};

int main() {
    TreeTraversal tree;
    tree.insertValue(20);
    tree.insertValue(10);
    tree.insertValue(30);
    tree.insertValue(5);

    cout << "DFS Traversal of Tree: ";
    tree.depthFirstSearch(tree.rootNode);
    cout << endl;

    return 0;
}

lab 13
part 2
#include <iostream>
#include <vector>
using namespace std;

class GraphTraversal {
    vector<vector<int>> adjacencyList;

public:
    GraphTraversal(int nodes) {
        adjacencyList.resize(nodes);
    }

    void addEdge(int u, int v) {
        adjacencyList[u].push_back(v);
    }

    void depthFirstSearch(int startNode, vector<bool>& visited) {
        visited[startNode] = true;
        cout << startNode << " ";

        for (int neighbor : adjacencyList[startNode]) {
            if (!visited[neighbor]) {
                depthFirstSearch(neighbor, visited);
            }
        }
    }
};

int main() {
    GraphTraversal graph(6);
    graph.addEdge(0, 1);
    graph.addEdge(0, 2);
    graph.addEdge(1, 3);
    graph.addEdge(2, 4);

    vector<bool> visited(6, false);
    cout << "DFS Traversal of Graph: ";
    graph.depthFirstSearch(0, visited);
    cout << endl;

    return 0;
}
 lab 13 
part 3
#include <iostream>
#include <queue>
using namespace std;

struct TreeNode {
    int data;
    TreeNode* leftChild;
    TreeNode* rightChild;
    TreeNode(int val) : data(val), leftChild(nullptr), rightChild(nullptr) {}
};

class TreeTraversal {
public:
    TreeNode* rootNode;

    TreeTraversal() : rootNode(nullptr) {}

    void insertValue(int val) {
        rootNode = insertHelper(rootNode, val);
    }

    void breadthFirstSearch() {
        if (rootNode == nullptr) return;
        queue<TreeNode*> q;
        q.push(rootNode);

        while (!q.empty()) {
            TreeNode* currentNode = q.front();
            q.pop();
            cout << currentNode->data << " ";

            if (currentNode->leftChild) q.push(currentNode->leftChild);
            if (currentNode->rightChild) q.push(currentNode->rightChild);
        }
    }

private:
    TreeNode* insertHelper(TreeNode* node, int val) {
        if (node == nullptr) return new TreeNode(val);
        if (val < node->data) {
            node->leftChild = insertHelper(node->leftChild, val);
        } else {
            node->rightChild = insertHelper(node->rightChild, val);
        }
        return node;
    }
};

int main() {
    TreeTraversal tree;
    tree.insertValue(20);
    tree.insertValue(10);
    tree.insertValue(30);
    tree.insertValue(5);

    cout << "BFS Traversal of Tree: ";
    tree.breadthFirstSearch();
    cout << endl;

    return 0;
}

lab 13
part 4
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

class GraphTraversal {
    vector<vector<int>> adjacencyList;

public:
    GraphTraversal(int nodes) {
        adjacencyList.resize(nodes);
    }

    void addEdge(int u, int v) {
        adjacencyList[u].push_back(v);
    }

    void breadthFirstSearch(int startNode) {
        vector<bool> visited(adjacencyList.size(), false);
        queue<int> q;
        q.push(startNode);
        visited[startNode] = true;

        while (!q.empty()) {
            int currentNode = q.front();
            q.pop();
            cout << currentNode << " ";

            for (int neighbor : adjacencyList[currentNode]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
    }
};

int main() {
    GraphTraversal graph(6);
    graph.addEdge(0, 1);
    graph.addEdge(0, 2);
    graph.addEdge(1, 3);
    graph.addEdge(2, 4);

    cout << "BFS Traversal of Graph: ";
    graph.breadthFirstSearch(0);
    cout << endl;

    return 0;
}




   
